# 명령 패턴 예제

# 명령 패턴의 주요 클래스 5가지
1. Command (명령)
Command는 모든 명령 객체가 구현해야 하는 인터페이스 또는 추상 클래스입니다. 이것은 일반적으로 Execute 메서드를 포함하여 실제 명령이 수행해야 할 작업을 정의합니다. 경우에 따라 UnExecute 또는 Undo 메서드도 포함하여 명령의 실행을 취소할 수 있습니다.

2. ConcreteCommand (구체적인 명령)
ConcreteCommand는 Command 인터페이스를 실제로 구현하는 클래스입니다. 이 클래스는 특정 작업과 관련된 로직을 포함하고, Receiver 객체에 작업 실행을 위임합니다. 예를 들어, MoveCommand는 게임 오브젝트를 이동시키는 구체적인 명령을 나타낼 수 있습니다.

3. Receiver (수신자)
Receiver는 명령이 실제로 작업을 수행하는 객체입니다. ConcreteCommand는 Receiver에 있는 메서드를 호출하여 요청된 작업을 수행합니다. 예를 들어, MoveCommandReceiver는 실제 이동 로직을 수행하는 메서드를 가진 클래스가 될 것입니다.

4. Invoker (호출자)
Invoker는 하나 이상의 Command 객체를 저장하고, 명령을 실행할 시기를 결정하는 역할을 합니다. 사용자의 입력을 받거나, 메뉴 선택 등을 통해 특정 명령을 실행하라고 요청할 수 있습니다. Invoker는 또한 명령의 실행을 취소하고 재실행하는 메커니즘을 관리할 수도 있습니다.

5. Client (사용자)
사용자의 입력을 받아 ConcreteCommand를 생성하고, 이를 Invoker에 할당하는 역할을 합니다. 명령 패턴에서는 일반적으로 클라이언트가 명령 객체를 생성하고 실행할 명령을 설정합니다.

이 5가지 주요 구성 요소를 통해 명령 패턴은 유연하고 확장 가능한 소프트웨어 아키텍처를 제공합니다. 예를 들어, 새로운 명령을 시스템에 추가하려면 ConcreteCommand 클래스를 추가하고, 이를 Invoker가 사용할 수 있도록 만들면 됩니다. Receiver의 로직은 변경하지 않고도 다양한 ConcreteCommand에서 재사용할 수 있습니다.

# 기능
→ GUI 버튼을 이용해 도트를 상하좌우로 이동시킬 수 있습니다.
→ 이동 명령은 저장되어 실행 취소(Undo)와 다시 실행(Redo)이 가능합니다.
→ 화면에는 현재까지의 명령 목록과 현재 명령이 어떤 것인지를 표시합니다.

# 클래스 구성 순서대로 위의 주요 클래스 순서와 매칭됨
* **ICommand** - 실행될 작업을 정의한 인터페이스입니다.
* **MoveCommand** - ICommand 인터페이스를 상속받아 구현된 클래스로, 게임 오브젝트를 특정 방향과 거리로 이동시키는 명령을 캡슐화합니다. Execute와 UnExecute 메서드를 통해 이동과 이동 취소 기능을 수행합니다.
* **Receiver** - 실제로 작업을 수행하는 로직이 포함된 클래스입니다. ConcreteCommand에 의해 호출되는 메서드를 가지고 있습니다.
* **CommandInvoker** - 명령의 Execute 메서드를 호출하여 작업을 처리합니다. 또한, UnExecute 메서드를 통해 명령의 실행을 취소할 수 있습니다.
* **InputHandler** - 사용자 입력을 받아 MoveCommand를 생성하고 CommandInvoker에 명령을 전달합니다. 명령은 List에 저장되어 실행 취소와 다시 실행 관리에 사용됩니다.
